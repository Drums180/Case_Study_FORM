---
title: 'Regresión Logística'
author: "Daniel Nájera - A01709578"
date: "2024-03-04"
output: 
  html_document: 
    toc: TRUE
    toc_float: TRUE
---

# RH - Regresión Logistica

Este documento está dedicado al análisis de diferentes modelos de regresión logistica, aplicados a la **Situación Problema 1: Rotación de Personal**. Utilizamos la base de RH para estos modelos.

La regresión logística es un modelo estadístico utilizado para predecir la probabilidad de un resultado binario o dicotómico, es decir, un resultado que puede tener uno de dos posibles valores, típicamente representados como 0 y 1. 

Ventajas:

Es fácil de interpretar en términos de probabilidades.
Puede manejar múltiples variables independientes.
No requiere que las variables independientes sean linealmente relacionadas con la variable dependiente.

## Librerías Requeridas

```{r message=FALSE, warning=FALSE}
# Cargar las librerías necesarias
library(foreign)
library(modelr)
library(dplyr)
library(tidyverse) 
library(ggplot2)
library(broom)
library(ISLR)          # great textbook to learn, explore, and put in practice data science skills.  
library(readr)
library(caret)
library(e1071)
library(class)
library(ROCR)
library(pROC)
library(lmtest)
library(caTools)
library(rpart)
library(rpart.plot)
library(psych)  
library(ggpubr)
library(reshape)
library(Metrics)
library(mlbench)
library(rsample)
library(cluster)     # clustering algorithms
library(factoextra)  # clustering algorithms & visualization
library(gridExtra)
library(ggplot2)
library(zoo)
library(dplyr)
library(modeest)
library(caret)
library(tibble)
library(pROC)
library(randomForest)
library(irr)
library(corrplot)
library(vcd)
library(car)
```

## Bases de Datos Necesarias

Como se mencionó anteriormente, el análisis para abordar la **Situación Problema 1** involucra dos conjuntos de datos principales:

**Base de Datos de Bajas - Capital Humano**: Este conjunto de datos ofrece un análisis detallado de los factores demográficos de los empleados. Permite identificar las características personales que pueden influir en la decisión de un empleado de continuar en la empresa o darse de baja.

```{r message=FALSE, warning=FALSE}
# Cargar datos
datos <- read.csv("/Users/danielnajera/Downloads/Datos_FORM_RH_FJ2024.csv")
```

```{r message=FALSE, warning=FALSE}
str(datos)
```

## Transformaciones Necesarias

Las transformaciones aplicadas a la base de datos de Capital Humano tienen como objetivo mejorar la interpretabilidad y utilidad de las variables para el análisis. Estas modificaciones son esenciales para adaptar los datos demográficos y de empleo a formatos que faciliten la exploración y el modelado estadístico.

```{r message=FALSE, warning=FALSE}
# Cambiar nombres de columnas a camelCase
nuevos_nombres <- names(datos) %>%
  str_replace_all("\\s+", " ") %>%  # Reemplazar múltiples espacios por uno solo
  str_to_lower() %>%               # Convertir todo a minúsculas
  str_replace_all("[^[:alnum:] ]", "") %>%  # Eliminar caracteres no alfanuméricos
  str_replace_all(" ", "") %>%     # Eliminar espacios
  str_replace_all("(?<=[a-z])([A-Z])", "\\1\\2") %>%  # Asegurar camelCase
  make.names()  # Evitar nombres de variables inválidos

names(datos) <- nuevos_nombres

```

```{r message=FALSE, warning=FALSE}
str(datos)
summary(datos)
```

Eliminamos los acentos de algunas variables.

```{r message=FALSE, warning=FALSE}
names(datos)[names(datos) == "género"] <- "genero"
names(datos)[names(datos) == "factordecréditoinfonavit"] <- "factordecreditoinfonavit"
names(datos)[names(datos) == "dirección"] <- "direccion"
names(datos)[names(datos) == "nodecréditoinfonavit"] <- "nodecreditoinfonavit"
names(datos)[names(datos) == "número"] <- "numero"
names(datos)[names(datos) == "númerodetélefono"] <- "numerodetelefono"
```

Base de Capital Humano

El siguiente bloque de código en R realiza varias transformaciones importantes en la base de datos:

1. **Conversión de Fechas**: Las columnas que contienen fechas se convierten al formato de fecha estándar de R para asegurar que se manejen correctamente como datos temporales.
2. **Extracción de Componentes de Fecha**: Se extraen el mes y el año de nacimiento del empleado a partir de la fecha de nacimiento para análisis específicos relacionados con la temporalidad.
3. **Cálculo de la Edad**: Se calcula la edad del empleado al convertir la diferencia entre la fecha de nacimiento y la fecha actual en años completos.
4. **Cálculo de la Antigüedad**: Se calcula la antigüedad en días, considerando tanto a los empleados activos como a los que ya no están en la empresa, utilizando la fecha de alta y, si está disponible, la fecha de baja.
5. **Mes de Entrada**: Se obtiene el mes de entrada del empleado a la empresa, lo cual es útil para analizar tendencias estacionales en las contrataciones.

```{r message=FALSE, warning=FALSE}
datos$fechadenacimiento <- as.Date(datos$fechadenacimiento, format = "%Y-%m-%d")
datos$fechadealta <- as.Date(datos$fechadealta, format = "%Y-%m-%d")
datos$fechadebaja <- as.Date(datos$fechadebaja, format = "%Y-%m-%d")

# Transformar el dataframe
datos <- datos %>%
  mutate(
    Mes_Nacimiento = month(fechadenacimiento),
    Año_Nacimiento = year(fechadenacimiento),
    
    # Calcular la edad en años utilizando la fecha de nacimiento y la fecha actual
    Edad = as.integer(interval(fechadenacimiento, Sys.Date()) %/% years(1)),
    # Calcular la antigüedad en días directamente
    Antigüedad = as.integer(ifelse(is.na(fechadebaja), Sys.Date() - fechadealta, fechadebaja - fechadealta)),
    Mes_Entrada = if_else(is.na(fechadealta), as.integer(primermes), month(fechadealta))
  )

# Contar cuántos NA hay en cada columna nueva y mostrar los resultados
na_counts <- sapply(datos[c("Mes_Nacimiento", "Año_Nacimiento", "Edad", "Antigüedad", "Mes_Entrada")], function(x) sum(is.na(x)))
print(na_counts)
```

Vamos a convertir variables de caracteres en factores para que podamos mostrar estadísticas descriptivas.

```{r message=FALSE, warning=FALSE}
datos$genero<-as.factor(datos$genero)
datos$puesto<-as.factor(datos$puesto)
datos$dpto<-as.factor(datos$dpto)
datos$estado<-as.factor(datos$estado)
datos$estatus<-as.factor(datos$estatus)
datos$estado_civil<-as.factor(datos$estadocivil)
```

```{r message=FALSE, warning=FALSE}
na_count <- colSums(is.na(datos))
na_count
```

Revisemos la estructura de nuestro conjunto de nuestros datos.

```{r message=FALSE, warning=FALSE}
#View(datos)
```

```{r message=FALSE, warning=FALSE}
summary(datos)
```

## K-MEANS Clustering

K-Means Clustering.
El objetivo principal de K-Means Clustering es identificar patrones de datos y agrupar observaciones de datos en diferentes grupos en función de sus similitudes. Vale la pena mencionar que K-Means Clustering es un algoritmo de agrupación no supervisado. También es muy útil cuando se trabaja con un conjunto de datos que no tiene etiquetas.

Exploremos la agrupación de k-medias relacionada con "edad" en años

Cabe mencionar que el análisis de agrupamiento de k-medias solo puede incluir variables cuantitativas.

```{r message=FALSE, warning=FALSE}
rh_edad<-datos %>% select(genero,estadocivil,sd,Edad)
```

La normalización de un conjunto de datos (variables cuantitativas) utilizando el valor medio y la desviación estándar se realiza mediante scale()

```{r message=FALSE, warning=FALSE}
rh_edad_norm<-scale(rh_edad[3:4]) 
```

### fviz

Utilizamos la función fviz para ver el diagrama de codo para visualizar el número óptimo de grupos

```{r message=FALSE, warning=FALSE}
fviz_nbclust(rh_edad_norm, kmeans, method="wss")+ # wss method considers total within sum of square
  geom_vline(xintercept=3, linetype=2)+           # optimal number of clusters is computed with the default method = "euclidean"
  labs(subtitle = "Elbow method")  
```

¿Cómo elegir el número adecuado de clusters?
La suma de los cuadrados dentro del grupo es un indicador de la dispersión de las observaciones dentro de cada grupo. En términos generales, un grupo con una suma baja de cuadrados es más denso y compacto que un grupo con una suma alta de cuadrados. Normalmente, se selecciona el número ideal de clusters cuando se observa que la SSE empieza a estabilizarse y se forma una curva en codo.

### Agrupado.

```{r message=FALSE, warning=FALSE}
edad_cluster1 <- kmeans(rh_edad_norm, 3)

# Visualizar los clusters
fviz_cluster(edad_cluster1, data = rh_edad_norm)
```

La selección de 5 grupos explica aproximadamente el 85% de la variabilidad del conjunto de datos.

Agreguemos la información de los grupos estimados al conjunto de datos original para que podamos interpretar los resultados.

```{r message=FALSE, warning=FALSE}
rh_logistic_alt1<-datos
rh_logistic_alt1$Clusters<-edad_cluster1$cluster
```

Creemos un conjunto de datos para que podamos identificar algunas características de “edad” por grupo.

```{r message=FALSE, warning=FALSE}
rh_logistic_alt2<-rh_logistic_alt1 %>% group_by(Clusters) %>% summarise(Edad=max(Edad)) %>% arrange(desc(Edad))
```

Agrupamos los clusters por nombre

```{r message=FALSE, warning=FALSE}
rh_logistic_alt1$Cluster_Names<-factor(rh_logistic_alt1$Clusters,levels = c(1,2,3), 
                              labels=c("Avanzada","Adulta","Jóven"))
```

Agrupamos los grupos por nombres de grupo y resumir las columnas

```{r message=FALSE, warning=FALSE}
rh_logistic_alt3<-rh_logistic_alt1 %>% group_by(Cluster_Names) %>% summarize(edad_años=max(Edad), 
                                                             salario=mean(sd),
                                                             Count=n())
```

### Tabla de la agrupación.

Vemos los resultados de la agrupación en la tabla.

```{r message=FALSE, warning=FALSE}
clusters<-as.data.frame(rh_logistic_alt3)
clusters
```

## Regresión logistica.

### Dividir datos en train y test.

```{r message=FALSE, warning=FALSE}
set.seed(123) # useful for creating simulations or random objects that can be reproduced
training<-rh_logistic_alt1$Cluster_Names %>%     # training dataset is implemented to build up a model
  createDataPartition(p=0.75,list=FALSE)
train.data<-rh_logistic_alt1[training, ]
test.data<-rh_logistic_alt1[-training, ]    
```

### Modelo 1. Regresión logistica simple.

```{r message=FALSE, warning=FALSE}
logit_model1<-glm(estatus~sd, data=train.data, family=binomial)
summary(logit_model1)
```

```{r message=FALSE, warning=FALSE}
contrasts(test.data$estatus) 
```

Mostramos las probabilidades de observaciones del conjunto de datos relacionadas con "bajas" y "no bajas"

```{r message=FALSE, warning=FALSE}
probabilities<-logit_model1 %>% predict(test.data,type="response")
predicted.classes<-ifelse(probabilities > 0.5, "baja", "no_baja")
head(probabilities) 
```

```{r message=FALSE, warning=FALSE}
head(predicted.classes)
```

#### Evaluación del modelo.

Evaluemos la precisión del modelo de regresión logística estimado 1.

```{r message=FALSE, warning=FALSE}
test.data$logit_model1_prob <- predict(logit_model1, test.data, type="response")

test.data <- test.data  %>% mutate(logit_model1_pred = 1*(logit_model1_prob > .50) + 0,
                         bajas_binary_1 = 1*(estatus == "baja") + 0)

test.data <- test.data %>% mutate(accurate_1=1*(logit_model1_pred == bajas_binary_1))
sum(test.data$accurate_1)/nrow(test.data) 
```

El R2 calculado indica que aproximadamente el 79% de la variación en la variable dependiente se explica por la especificación del modelo logit.

Gráfico de regresión logística que muestra una curva en forma de S.

```{r message=FALSE, warning=FALSE}
ggplot(rh_logistic_alt1,aes(x=sd, y=as.numeric(estatus)-1)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, fullrange=TRUE, method.args=list(family=binomial)) + 
  ylab("Probability") + xlim(100,500)+
  labs(
    title = "Logistic Regression Model", 
    x = "Salario Diario",
    y = "Probability of Bajas"
  )
```

##### Matriz de confusión. 

```{r message=FALSE, warning=FALSE}
prediccion_rl1 <- predict(logit_model1, test.data, type = "response")

confusion_rl1 <- confusionMatrix(as.factor(ifelse(prediccion_rl1>0.6, "baja", "activo")), test.data$estatus, positive = "activo")
confusion_rl1
```

##### AIC.

```{r message=FALSE, warning=FALSE}
AIC(logit_model1)
```

### Modelo 2. Regresión logistica multiple.

```{r message=FALSE, warning=FALSE}
logit_model2<-glm(estatus ~ sd + Edad, data=train.data, family=binomial(link='logit'))
summary(logit_model2)
```

#### Evaluación del modelo.

Evaluemos la precisión del modelo de regresión logística estimado 1.

```{r message=FALSE, warning=FALSE}
test.data$logit_model2_prob <- predict(logit_model2, test.data, type="response")

test.data <- test.data  %>% mutate(logit_model2_pred = 1*(logit_model2_prob > .50) + 0,
                                   bajas_binary_2 = 1*(estatus == "baja") + 0)

test.data <- test.data %>% mutate(accurate_2=1*(logit_model2_pred == bajas_binary_2))
sum(test.data$accurate_2)/nrow(test.data) 
```

Gráfico de regresión logística que muestra una curva en forma de S.

```{r message=FALSE, warning=FALSE}
ggplot(rh_logistic_alt1,aes(x=Edad, y=as.numeric(estatus)-1)) + 
  geom_point(alpha=.5) +
  stat_smooth(method="glm", se=FALSE, fullrange=TRUE, method.args = list(family=binomial)) + 
  ylab("Probability") + xlim(18,75)+
  labs(
    title = "Logistic Regression Model", 
    x = "Edad",
    y = "Probability of Bajas"
  )
```

##### Matriz de confusión.

```{r message=FALSE, warning=FALSE}
prediccion_rl2 <- predict(logit_model2, test.data, type = "response")

confusion_rl2 <- confusionMatrix(as.factor(ifelse(prediccion_rl2>0.6, "baja", "activo")), test.data$estatus, positive = "activo")
confusion_rl2
```

##### Diagnóstico del Modelo.

```{r message=FALSE, warning=FALSE}
vif(logit_model2)
```

##### AIC.

```{r message=FALSE, warning=FALSE}
AIC(logit_model2)
```

### Modelo 3. Regresión logistica multiple.

Consideremos nuestros resultados estimados del análisis de agrupamiento de K-Means.

```{r message=FALSE, warning=FALSE}
logit_model3<-glm(estatus~sd+Cluster_Names, data=train.data, family=binomial(link='logit'))
summary(logit_model3)
```

#### Evaluación del modelo.

```{r message=FALSE, warning=FALSE}
test.data$logit_model3_prob <- predict(logit_model3, test.data, type="response")

test.data <- test.data  %>% mutate(logit_model3_pred = 1*(logit_model3_prob > .50) + 0,
                                   bajas_binary_3 = 1*(estatus == "baja") + 0)

test.data <- test.data %>% mutate(accurate_3=1*(logit_model3_pred == bajas_binary_3))
sum(test.data$accurate_3)/nrow(test.data) 
```

El R2 calculado indica que aproximadamente el 82% de la variación en la variable dependiente se explica por la especificación del modelo logit.

##### Diagnóstico del Modelo.

```{r message=FALSE, warning=FALSE}
vif(logit_model3)
```

##### Matriz de confusión.

```{r message=FALSE, warning=FALSE}
prediccion_rl3 <- predict(logit_model3, test.data, type = "response")

confusion_rl3 <- confusionMatrix(as.factor(ifelse(prediccion_rl3>0.6, "baja", "activo")), test.data$estatus, positive = "activo")
confusion_rl3
```

##### AIC.

```{r message=FALSE, warning=FALSE}
AIC(logit_model3)
```

## Interpretación de los resultados.

- El coeficiente de sd es -0.014293. Esto significa que por cada aumento de una unidad en sd, el logaritmo de las probabilidades relativas (log-odds) de que el estatus sea "baja" (frente a "activo") disminuye en aproximadamente 0.014293. Este hallazgo es estadísticamente significativo, lo que proporciona una fuerte evidencia de que sd es un predictor relevante para estatus.
- Al considerar los resultados del método K-Means Clustering, el modelo logit estimado mejora los resultados de la regresión. Primero, la edad en años se relaciona negativamente con la probabilidad de “bajas”, sin embargo, ninguno es estadisticamente significativo, esto sugiere que estas categorías de Cluster_Names no tienen un efecto significativo en estatus en el modelo ajustado. En segundo lugar, el R2 no es mayor que el de otros modelos estimados, sin embargo tiene un mayor accuracy y un AIC menor que los otros modelos. En resumen, los resultados estimados indican que el aumento de la edad reduce la probabilidad de “bajas”, pero este resultado difiere entre grupos de edad.

## Referencia.

Thron, James. Logistic Regression Explained. Source: https://towardsdatascience.com/logistic-regression-explained-9ee73cede081